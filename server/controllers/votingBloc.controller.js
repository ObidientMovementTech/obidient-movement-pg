import VotingBloc from '../models/votingBloc.model.js';
import User from '../models/user.model.js';
import VotingBlocBroadcast from '../models/votingBlocBroadcast.model.js';
import VotingBlocMessage from '../models/votingBlocMessage.model.js';
import Notification from '../models/notification.model.js';
import s3Client from '../config/aws.js';
import { uploadToS3 } from '../utils/s3Upload.js';
import { sendVotingBlocBroadcastEmail, sendVotingBlocPrivateMessageEmail, sendVotingBlocInvitationEmail, sendVotingBlocRemovalEmail } from '../utils/emailHandler.js';
import { transformVotingBloc, transformUser } from '../utils/mongoCompat.js';
import { query } from '../config/db.js';

// Helper function to safely extract ID from object or string
const getId = (obj) => {
  if (typeof obj === 'string') return obj;
  if (typeof obj === 'object' && obj !== null) return obj.id || obj._id;
  return obj;
};

const generateJoinCode = () => {
  return Math.random().toString(36).slice(2, 10); // 8 characters
};

// Create new voting bloc
export const createVotingBloc = async (req, res) => {
  try {
    const {
      name,
      description,
      goals,
      targetCandidate,
      scope,
      location,
      bannerImageUrl,
      richDescription,
      toolkits,
    } = req.body;

    const joinCode = generateJoinCode();

    const user = await User.findById(req.userId);
    if (!user) {
      return res.status(404).json({ message: 'User not found' });
    }

    // Check if user already has an auto-generated voting bloc
    const existingAutoBlocs = await VotingBloc.findByCreator(req.userId, { limit: 10 });
    const hasAutoGeneratedBloc = existingAutoBlocs.some(bloc => bloc.isAutoGenerated);

    // KYC verification required for custom voting blocs (not auto-generated ones)
    if (hasAutoGeneratedBloc && user.kycStatus !== 'approved') {
      return res.status(403).json({
        message: 'KYC verification is required to create additional voting blocs. Please complete your KYC verification first.',
        requiresKyc: true
      });
    }

    const newVotingBloc = await VotingBloc.create({
      name,
      description,
      goals,
      targetCandidate,
      scope,
      location,
      bannerImageUrl,
      richDescription,
      joinCode,
      toolkits,
      creator: req.userId,
      members: [req.userId],
    });

    res.status(201).json({
      success: true,
      message: 'Voting bloc created successfully',
      votingBloc: transformVotingBloc(newVotingBloc),
    });
  } catch (error) {
    console.error('Error creating voting bloc:', error);
    res.status(500).json({ message: 'Server error' });
  }
};

// Join voting bloc
export const joinVotingBloc = async (req, res) => {
  try {
    const { joinCode } = req.body;

    const votingBloc = await VotingBloc.findByJoinCode(joinCode);
    if (!votingBloc) {
      return res.status(404).json({ message: 'Voting bloc not found' });
    }

    // Ensure members array exists
    if (!votingBloc.members) {
      votingBloc.members = [];
    }

    // Ensure invitations array exists
    if (!votingBloc.invitations) {
      votingBloc.invitations = [];
    }

    // Ensure memberMetadata array exists
    if (!votingBloc.memberMetadata) {
      votingBloc.memberMetadata = [];
    }

    if (votingBloc.members.includes(req.userId)) {
      return res.status(400).json({ message: 'You are already a member of this voting bloc' });
    }

    // Get the user's information to check for pending invitations
    const user = await User.findById(req.userId);
    if (!user) {
      return res.status(404).json({ message: 'User not found' });
    }

    // Check for pending invitations and update status to accepted
    const pendingInvitation = votingBloc.invitations.find(invitation =>
      invitation.status === 'pending' && (
        (invitation.invitedUser && getId(invitation.invitedUser) === req.userId) ||
        (invitation.invitedEmail && invitation.invitedEmail === user.email)
      )
    );

    if (pendingInvitation) {
      pendingInvitation.status = 'accepted';
      pendingInvitation.responseDate = new Date();
    }

    // Add user to members
    votingBloc.members.push(req.userId);

    // Create member metadata
    const existingMetadata = votingBloc.memberMetadata.find(meta => getId(meta.userId) === req.userId);
    if (!existingMetadata) {
      votingBloc.memberMetadata.push({
        userId: req.userId,
        joinDate: new Date(),
        decisionTag: 'Undecided',
        contactTag: 'No Response',
        engagementLevel: 'Medium',
        location: {
          state: user.personalInfo?.currentLocation?.state || '',
          lga: user.personalInfo?.currentLocation?.lga || '',
          ward: user.personalInfo?.currentLocation?.ward || '',
        }
      });
    }

    await votingBloc.save();

    res.status(200).json({
      success: true,
      message: 'Successfully joined voting bloc',
      votingBloc: transformVotingBloc(votingBloc),
    });
  } catch (error) {
    console.error('Error joining voting bloc:', error);
    res.status(500).json({ message: 'Server error' });
  }
};

// Get all voting blocs owned by current user
export const getOwnedVotingBlocs = async (req, res) => {
  try {
    console.log(`ðŸ” Fetching owned voting blocs for user: ${req.userId}`);

    const votingBlocs = await VotingBloc.findByCreator(req.userId, {
      limit: 50,
      offset: 0,
      includeDetails: true  // Include creator details and member counts
    });

    console.log(`ðŸ“Š Found ${votingBlocs.length} owned voting blocs for user ${req.userId}`);
    votingBlocs.forEach((bloc, index) => {
      console.log(`  ${index + 1}. "${bloc.name}" (ID: ${bloc.id}, isAutoGenerated: ${bloc.isAutoGenerated})`);
    });

    const transformedBlocs = transformVotingBloc(votingBlocs);
    console.log(`âœ… Transformed ${transformedBlocs.length} voting blocs for response`);

    res.status(200).json({
      success: true,
      votingBlocs: transformedBlocs,
    });
  } catch (error) {
    console.error('âŒ Error fetching owned voting blocs:', error);
    res.status(500).json({ message: 'Server error' });
  }
};

// Get all voting blocs user has joined
export const getJoinedVotingBlocs = async (req, res) => {
  try {
    // For now, return empty array as this functionality needs a custom query
    // TODO: Implement findByMember method in VotingBloc model
    console.log('getJoinedVotingBlocs: This method needs to be implemented with PostgreSQL query');

    res.status(200).json({
      success: true,
      votingBlocs: [],
    });
  } catch (error) {
    console.error('Error fetching joined voting blocs:', error);
    res.status(500).json({ message: 'Server error' });
  }
};

// Get voting bloc by ID
export const getVotingBlocById = async (req, res) => {
  try {
    const { id } = req.params;

    const votingBloc = await VotingBloc.findById(id, true); // includeDetails = true

    if (!votingBloc) {
      return res.status(404).json({ message: 'Voting bloc not found' });
    }

    res.status(200).json({
      success: true,
      votingBloc: transformVotingBloc(votingBloc),
    });
  } catch (error) {
    console.error('Error fetching voting bloc:', error);
    res.status(500).json({ message: 'Server error' });
  }
};

// Get voting bloc by join code
export const getVotingBlocByJoinCode = async (req, res) => {
  try {
    const { joinCode } = req.params;

    const votingBloc = await VotingBloc.findByJoinCode(joinCode);

    if (!votingBloc) {
      return res.status(404).json({ message: 'Voting bloc not found' });
    }

    res.status(200).json({
      success: true,
      votingBloc: transformVotingBloc(votingBloc),
    });
  } catch (error) {
    console.error('Error fetching voting bloc by join code:', error);
    res.status(500).json({ message: 'Server error' });
  }
};

// Update voting bloc
export const updateVotingBloc = async (req, res) => {
  try {
    const { id } = req.params;
    const updateData = req.body;

    const votingBloc = await VotingBloc.findById(id);
    if (!votingBloc) {
      return res.status(404).json({ message: 'Voting bloc not found' });
    }

    if (getId(votingBloc.creator) !== req.userId) {
      return res.status(403).json({ message: 'You can only update your own voting blocs' });
    }

    // Prevent editing of auto-generated voting blocs
    if (votingBloc.isAutoGenerated) {
      return res.status(403).json({
        message: 'Auto-generated voting blocs cannot be edited. They are managed by admin via template sync.'
      });
    }

    const updatedVotingBloc = await VotingBloc.findByIdAndUpdate(id, updateData);

    res.status(200).json({
      success: true,
      message: 'Voting bloc updated successfully',
      votingBloc: transformVotingBloc(updatedVotingBloc),
    });
  } catch (error) {
    console.error('Error updating voting bloc:', error);
    res.status(500).json({ message: 'Server error' });
  }
};

// Delete voting bloc
export const deleteVotingBloc = async (req, res) => {
  try {
    const { id } = req.params;

    const votingBloc = await VotingBloc.findById(id);
    if (!votingBloc) {
      return res.status(404).json({ message: 'Voting bloc not found' });
    }

    if (getId(votingBloc.creator) !== req.userId) {
      return res.status(403).json({ message: 'You can only delete your own voting blocs' });
    }

    // Prevent deletion of auto-generated voting blocs
    if (votingBloc.isAutoGenerated) {
      return res.status(403).json({
        message: 'Auto-generated voting blocs cannot be deleted. They are managed by admin.'
      });
    }

    await VotingBloc.findByIdAndDelete(id);

    res.status(200).json({
      success: true,
      message: 'Voting bloc deleted successfully',
    });
  } catch (error) {
    console.error('Error deleting voting bloc:', error);
    res.status(500).json({ message: 'Server error' });
  }
};

// Upload voting bloc banner image
export const uploadVotingBlocBannerImage = async (req, res) => {
  try {
    if (!req.file) {
      return res.status(400).json({ message: 'No file provided' });
    }

    const imageUrl = await uploadToS3(req.file, {
      folder: 'voting-blocs/banners'
    });

    res.status(200).json({
      success: true,
      imageUrl,
      message: 'Banner image uploaded successfully',
    });
  } catch (error) {
    console.error('Error uploading banner image:', error);
    res.status(500).json({
      message: 'Failed to upload banner image',
      error: error.message
    });
  }
};

// Upload rich description image
export const uploadRichDescriptionImage = async (req, res) => {
  try {
    if (!req.file) {
      return res.status(400).json({ message: 'No file provided' });
    }

    const imageUrl = await uploadToS3(req.file, {
      folder: 'voting-blocs/rich-description'
    });

    res.status(200).json({
      success: true,
      imageUrl,
      message: 'Rich description image uploaded successfully',
    });
  } catch (error) {
    console.error('Error uploading rich description image:', error);
    res.status(500).json({
      message: 'Failed to upload rich description image',
      error: error.message
    });
  }
};

// Get all voting blocs (for browsing)
export const getAllVotingBlocs = async (req, res) => {
  try {
    const { page = 1, limit = 10, scope, state, lga } = req.query;

    // Use the findAll method with pagination
    const offset = (page - 1) * limit;
    const votingBlocs = await VotingBloc.findAll({
      limit: parseInt(limit),
      offset,
      status: 'active',
      orderBy: 'totalMembers', // Order by member count first
      orderDirection: 'DESC'
    });

    // For now, we'll estimate total count since we don't have a count method
    // In a real scenario, you'd want to add a count method to the model
    const total = votingBlocs.length; // This is not accurate for pagination, but works for now

    res.status(200).json({
      success: true,
      votingBlocs: transformVotingBloc(votingBlocs),
      pagination: {
        total,
        page: parseInt(page),
        pages: Math.ceil(total / limit),
      },
    });
  } catch (error) {
    console.error('Error fetching all voting blocs:', error);
    res.status(500).json({ message: 'Server error' });
  }
};

// Send invitation to join voting bloc
export const sendInvitation = async (req, res) => {
  try {
    const { votingBlocId, invitedUserId, inviteType } = req.body;

    const votingBloc = await VotingBloc.findById(votingBlocId);
    if (!votingBloc) {
      return res.status(404).json({ message: 'Voting bloc not found' });
    }

    // Check if user is a member of the voting bloc
    if (!votingBloc.members.includes(req.userId)) {
      return res.status(403).json({ message: 'You must be a member to send invitations' });
    }

    // Check if invitation already exists
    const existingInvitation = votingBloc.invitations.find(
      inv => getId(inv.invitedUser) === invitedUserId && inv.status === 'pending'
    );

    if (existingInvitation) {
      return res.status(400).json({ message: 'Invitation already sent to this user' });
    }

    // Add invitation
    votingBloc.invitations.push({
      invitedBy: req.userId,
      invitedUser: invitedUserId,
      inviteType,
      status: 'pending',
    });

    await votingBloc.save();

    res.status(200).json({
      success: true,
      message: 'Invitation sent successfully',
    });
  } catch (error) {
    console.error('Error sending invitation:', error);
    res.status(500).json({ message: 'Server error' });
  }
};

// Resend invitation
export const resendInvitation = async (req, res) => {
  try {
    const { id } = req.params; // voting bloc id
    const { invitationId } = req.body;

    const votingBloc = await VotingBloc.findById(id);
    if (!votingBloc) {
      return res.status(404).json({ message: 'Voting bloc not found' });
    }

    // Check if user is the creator or member
    if (getId(votingBloc.creator) !== req.userId && !votingBloc.members.includes(req.userId)) {
      return res.status(403).json({ message: 'You can only resend invitations for your own voting blocs' });
    }

    // Find the invitation
    const invitation = votingBloc.invitations.id(invitationId);
    if (!invitation) {
      return res.status(404).json({ message: 'Invitation not found' });
    }

    // Check if invitation is still pending
    if (invitation.status !== 'pending') {
      return res.status(400).json({ message: 'Can only resend pending invitations' });
    }

    // Get the inviter's details
    const inviter = await User.findById(req.userId);
    if (!inviter) {
      return res.status(404).json({ message: 'Inviter not found' });
    }

    // Resend email invitation if it's an email invitation
    if (invitation.inviteType === 'email') {
      try {
        let recipientEmail;
        let recipientName;

        if (invitation.invitedUser) {
          // Existing user
          const invitedUser = await User.findById(invitation.invitedUser);
          if (invitedUser) {
            recipientEmail = invitedUser.email;
            recipientName = invitedUser.name;
          }
        } else if (invitation.invitedEmail) {
          // Non-existing user
          recipientEmail = invitation.invitedEmail;
          recipientName = invitation.invitedEmail.split('@')[0];
        }

        if (recipientEmail) {
          const joinLink = `${process.env.CLIENT_URL}/voting-bloc/${votingBloc.joinCode}`;

          await sendVotingBlocInvitationEmail(
            recipientName,
            recipientEmail,
            inviter.name,
            votingBloc.name,
            joinLink,
            invitation.message
          );
        }
      } catch (emailError) {
        console.error('Failed to resend invitation email:', emailError);
        return res.status(500).json({ message: 'Failed to resend invitation email' });
      }
    }

    // Update invitation date
    invitation.inviteDate = new Date();
    await votingBloc.save();

    res.status(200).json({
      success: true,
      message: 'Invitation resent successfully',
    });
  } catch (error) {
    console.error('Error resending invitation:', error);
    res.status(500).json({ message: 'Server error' });
  }
};

// Clear responded invitations from history
export const clearRespondedInvitations = async (req, res) => {
  try {
    const { id } = req.params; // voting bloc id

    const votingBloc = await VotingBloc.findById(id);
    if (!votingBloc) {
      return res.status(404).json({ message: 'Voting bloc not found' });
    }

    // Check if user is the creator
    if (getId(votingBloc.creator) !== req.userId) {
      return res.status(403).json({ message: 'Only the creator can clear invitation history' });
    }

    // Remove all responded invitations (accepted or declined)
    const originalCount = votingBloc.invitations.length;
    votingBloc.invitations = votingBloc.invitations.filter(
      invitation => invitation.status === 'pending'
    );
    const clearedCount = originalCount - votingBloc.invitations.length;

    await votingBloc.save();

    res.status(200).json({
      success: true,
      message: `Cleared ${clearedCount} responded invitations from history`,
      clearedCount,
    });
  } catch (error) {
    console.error('Error clearing invitation history:', error);
    res.status(500).json({ message: 'Server error' });
  }
};

// Get leaderboard data
export const getLeaderboard = async (req, res) => {
  try {
    const {
      level = 'national',
      state,
      lga,
      ward,
      limit = 100,
      offset = 0
    } = req.query;

    let searchOptions = { status: 'active' };

    switch (level) {
      case 'ward':
        if (ward) searchOptions.locationWard = ward;
        break;
      case 'lga':
        if (lga) searchOptions.locationLga = lga;
        break;
      case 'state':
        if (state) searchOptions.locationState = state;
        break;
      case 'national':
      default:
        // No additional filter needed
        break;
    }

    const leaderboard = await VotingBloc.searchForLeaderboard({
      ...searchOptions,
      limit: Math.min(parseInt(limit) || 100, 100), // Cap at 100 for performance
      offset: parseInt(offset) || 0
    });

    res.status(200).json({
      success: true,
      leaderboard: transformVotingBloc(leaderboard),
      level,
      pagination: {
        limit: Math.min(parseInt(limit) || 100, 100),
        offset: parseInt(offset) || 0,
        total: leaderboard.length
      }
    });
  } catch (error) {
    console.error('Error fetching leaderboard:', error);
    res.status(500).json({ message: 'Server error' });
  }
};

// Leave voting bloc
export const leaveVotingBloc = async (req, res) => {
  try {
    const { id } = req.params;

    const votingBloc = await VotingBloc.findById(id);
    if (!votingBloc) {
      return res.status(404).json({ message: 'Voting bloc not found' });
    }

    if (getId(votingBloc.creator) === req.userId) {
      return res.status(400).json({ message: 'Creator cannot leave their own voting bloc' });
    }

    if (!votingBloc.members.includes(req.userId)) {
      return res.status(400).json({ message: 'You are not a member of this voting bloc' });
    }

    votingBloc.members = votingBloc.members.filter(
      memberId => getId(memberId) !== req.userId
    );

    await votingBloc.save();

    res.status(200).json({
      success: true,
      message: 'Successfully left voting bloc',
    });
  } catch (error) {
    console.error('Error leaving voting bloc:', error);
    res.status(500).json({ message: 'Server error' });
  }
};

// Get voting bloc invitations with status
export const getVotingBlocInvitations = async (req, res) => {
  try {
    const { id } = req.params;

    const votingBloc = await VotingBloc.findById(id, true); // includeDetails = true

    if (!votingBloc) {
      return res.status(404).json({ message: 'Voting bloc not found' });
    }

    // Check if user is the creator or member
    const isCreator = votingBloc.creator && votingBloc.creator.id === req.userId;
    const isMember = votingBloc.members && votingBloc.members.includes(req.userId);

    if (!isCreator && !isMember) {
      return res.status(403).json({ message: 'You can only view invitations for your own voting blocs' });
    }

    res.status(200).json({
      success: true,
      invitations: votingBloc.invitations,
    });
  } catch (error) {
    console.error('Error getting voting bloc invitations:', error);
    res.status(500).json({ message: 'Server error' });
  }
};

// Send invitation via email/phone
export const sendMemberInvitation = async (req, res) => {
  try {
    const { id } = req.params;
    const { email, phone, inviteType, message } = req.body;

    const votingBloc = await VotingBloc.findById(id, true); // includeDetails = true
    if (!votingBloc) {
      return res.status(404).json({ message: 'Voting bloc not found' });
    }

    // Check if user is the creator or member
    const isCreator = votingBloc.creator && votingBloc.creator.id === req.userId;
    const isMember = votingBloc.members && votingBloc.members.includes(req.userId);

    if (!isCreator && !isMember) {
      return res.status(403).json({ message: 'You can only send invitations for your own voting blocs' });
    }

    // Find user by email or phone
    let invitedUser = null;
    let isExistingUser = false;

    if (email) {
      invitedUser = await User.findOne({ email });
      if (invitedUser) {
        isExistingUser = true;

        // Check if user is already a member
        if (votingBloc.members.includes(invitedUser.id)) {
          return res.status(400).json({ message: 'User is already a member of this voting bloc' });
        }

        // Check if invitation already exists for existing user
        const existingInvitation = votingBloc.invitations.find(
          inv => inv.invitedUser && inv.invitedUser === invitedUser.id && inv.status === 'pending'
        );

        if (existingInvitation) {
          return res.status(400).json({ message: 'Invitation already sent to this user' });
        }
      } else {
        // Check if invitation already exists for this email (non-existing user)
        const existingEmailInvitation = votingBloc.invitations.find(
          inv => inv.invitedEmail === email && inv.status === 'pending'
        );

        if (existingEmailInvitation) {
          return res.status(400).json({ message: 'Invitation already sent to this email address' });
        }
      }
    } else if (phone) {
      invitedUser = await User.findOne({ phone });
      if (!invitedUser) {
        return res.status(404).json({ message: 'User not found with provided phone number. Phone invitations currently require existing users.' });
      }
      isExistingUser = true;

      // Check if user is already a member
      if (votingBloc.members.includes(invitedUser.id)) {
        return res.status(400).json({ message: 'User is already a member of this voting bloc' });
      }

      // Check if invitation already exists
      const existingInvitation = votingBloc.invitations.find(
        inv => inv.invitedUser && inv.invitedUser === invitedUser.id && inv.status === 'pending'
      );

      if (existingInvitation) {
        return res.status(400).json({ message: 'Invitation already sent to this user' });
      }
    }

    // Create invitation object
    const invitationData = {
      invitedBy: req.userId,
      inviteType,
      status: 'pending',
      message: message || `You've been invited to join ${votingBloc.name}`,
    };

    if (isExistingUser) {
      invitationData.invitedUser = invitedUser.id;
    } else {
      // For non-existing users, store email for future reference
      invitationData.invitedEmail = email;
    }

    // Add invitation
    votingBloc.invitations.push(invitationData);

    await votingBloc.save();

    // Send email invitation if inviteType is email
    if (inviteType === 'email' && email) {
      try {
        // Get the inviter's details
        const inviter = await User.findById(req.userId);

        // Create appropriate join/signup link using the public voting bloc page
        let joinLink;
        if (isExistingUser) {
          // Direct link to public voting bloc page for existing users
          joinLink = `${process.env.CLIENT_URL}/voting-bloc/${votingBloc.joinCode}`;
        } else {
          // For new users, link to public page with signup prompt
          joinLink = `${process.env.CLIENT_URL}/voting-bloc/${votingBloc.joinCode}`;
        }

        const recipientName = isExistingUser ? invitedUser.name : email.split('@')[0];

        await sendVotingBlocInvitationEmail(
          recipientName,
          email,
          inviter.name,
          votingBloc.name,
          joinLink,
          message
        );
      } catch (emailError) {
        console.error('Failed to send invitation email:', emailError);
        // Don't fail the whole request if email fails - invitation is still saved
      }
    }

    // TODO: Implement SMS/WhatsApp notifications for other invite types

    res.status(200).json({
      success: true,
      message: 'Invitation sent successfully',
      invitation: {
        ...(isExistingUser && invitedUser ? {
          invitedUser: {
            _id: invitedUser.id,
            name: invitedUser.name,
            email: invitedUser.email,
          }
        } : {
          invitedEmail: email
        }),
        inviteType,
        status: 'pending',
      },
    });
  } catch (error) {
    console.error('Error sending member invitation:', error);
    res.status(500).json({ message: 'Server error' });
  }
};

// Add manual member (for offline/rural members without platform accounts)
export const addManualMember = async (req, res) => {
  try {
    const { id } = req.params;
    const { name, phone, state, lga, ward } = req.body;

    // Validate required fields
    if (!name || !phone || !state || !lga) {
      return res.status(400).json({
        message: 'Name, phone, state, and LGA are required'
      });
    }

    const votingBloc = await VotingBloc.findById(id, true);
    if (!votingBloc) {
      return res.status(404).json({ message: 'Voting bloc not found' });
    }

    // Check if user is the creator or member
    const isCreator = votingBloc.creator && votingBloc.creator.id === req.userId;
    const isMember = votingBloc.members && votingBloc.members.includes(req.userId);

    if (!isCreator && !isMember) {
      return res.status(403).json({
        message: 'You can only add manual members to your own voting blocs'
      });
    }

    // Check if phone number already exists as manual member in this voting bloc
    const existingMemberQuery = `
      SELECT * FROM "votingBlocMembers" 
      WHERE "votingBlocId" = $1 AND "phoneNumber" = $2 AND "memberType" = 'manual'
    `;
    const existingMember = await query(existingMemberQuery, [id, phone.trim()]); if (existingMember.rows.length > 0) {
      return res.status(400).json({
        message: 'A manual member with this phone number already exists in this voting bloc'
      });
    }

    // Split name into first and last name (simple split on first space)
    const nameParts = name.trim().split(' ');
    const firstName = nameParts[0];
    const lastName = nameParts.slice(1).join(' ') || '';

    // Insert manual member into votingBlocMembers table
    const insertMemberQuery = `
      INSERT INTO "votingBlocMembers" (
        "votingBlocId", 
        "firstName",
        "lastName", 
        "phoneNumber", 
        "state", 
        "lga", 
        "ward",
        "memberType",
        "joinDate"
      ) VALUES ($1, $2, $3, $4, $5, $6, $7, 'manual', NOW())
      RETURNING *
    `;

    const newMember = await query(insertMemberQuery, [
      id,
      firstName,
      lastName,
      phone.trim(),
      state,
      lga,
      ward || null
    ]);

    // Update voting bloc member count
    const updateCountQuery = `
      UPDATE "votingBlocs" 
      SET "totalMembers" = (
        SELECT COUNT(*) FROM "votingBlocMembers" 
        WHERE "votingBlocId" = $1
      )
      WHERE id = $1
    `;
    await query(updateCountQuery, [id]);

    res.status(200).json({
      success: true,
      message: 'Manual member added successfully',
      member: {
        id: newMember.rows[0].id,
        name: `${firstName} ${lastName}`.trim(),
        phone: newMember.rows[0].phoneNumber,
        location: {
          state: newMember.rows[0].state,
          lga: newMember.rows[0].lga,
          ward: newMember.rows[0].ward
        },
        memberType: 'manual',
        joinDate: newMember.rows[0].joinDate
      }
    });
  } catch (error) {
    console.error('Error adding manual member:', error);
    res.status(500).json({ message: 'Server error' });
  }
};

// Send broadcast message to all members
export const sendBroadcastMessage = async (req, res) => {
  try {
    const { id } = req.params;
    const { message, messageType, channels } = req.body; // channels: ['email', 'whatsapp', 'sms', 'in-app']
    const userId = req.userId;

    const votingBloc = await VotingBloc.findById(id, true); // includeDetails = true

    if (!votingBloc) {
      return res.status(404).json({ message: 'Voting bloc not found' });
    }

    // Check if user is the creator
    const isCreator = votingBloc.creator && votingBloc.creator.id === userId;
    if (!isCreator) {
      return res.status(403).json({ message: 'Only the creator can send broadcast messages' });
    }

    // Get sender details
    const sender = await User.findById(userId);
    if (!sender) {
      return res.status(404).json({ message: 'Sender not found' });
    }

    // Save the broadcast message
    const newBroadcast = await VotingBlocBroadcast.create({
      votingBlocId: id,
      message,
      messageType: messageType || 'announcement',
      channels: channels || ['in-app'],
      sentBy: userId
    });

    // Get all members except the sender
    const recipients = votingBloc.memberDetails.filter(
      member => member.userId !== userId
    );

    let notifications = [];
    let emailsSent = 0;

    // Create in-app notifications for all recipients
    if (channels.includes('in-app')) {
      notifications = await Promise.all(
        recipients.map(member =>
          Notification.create({
            recipient: member.userId,
            type: "votingBlocBroadcast",
            title: `New ${messageType || 'message'} from "${votingBloc.name}"`,
            message,
            relatedVotingBloc: votingBloc.id,
          })
        )
      );
    }


    // Send emails if email channel is enabled
    if (channels.includes('email')) {
      try {
        const emailRecipients = recipients
          .filter(member => member.email)
          .map(member => ({ email: member.email }));

        if (emailRecipients.length > 0) {
          await sendVotingBlocBroadcastEmail(
            votingBloc.name,
            sender.name || 'Voting Bloc Creator',
            message,
            messageType || 'announcement',
            emailRecipients
          );
          emailsSent = emailRecipients.length;
        }
      } catch (emailError) {
        console.error('Error sending broadcast emails:', emailError);
        // Don't fail the request if email fails, but log it
      }
    }

    res.status(200).json({
      success: true,
      message: `Broadcast message sent to ${recipients.length} members`,
      data: {
        broadcast: newBroadcast,
        recipients: recipients.length,
        channels,
        notificationsSent: notifications.length,
        emailsSent
      }
    });
  } catch (error) {
    console.error('Error sending broadcast message:', error);
    res.status(500).json({ message: 'Server error' });
  }
};

// Remove member from voting bloc
export const removeMember = async (req, res) => {
  try {
    const { id, memberId } = req.params;
    const { reason } = req.body;

    const votingBloc = await VotingBloc.findById(id, true); // Get full details for manual members
    if (!votingBloc) {
      return res.status(404).json({ message: 'Voting bloc not found' });
    }

    // Check if user is the creator
    if (getId(votingBloc.creator) !== req.userId) {
      return res.status(403).json({ message: 'Only the creator can remove members' });
    }

    // Check if it's a manual member
    if (memberId.startsWith('manual_')) {
      // Handle manual member removal
      const manualMemberIndex = parseInt(memberId.split('_')[1]);
      const manualMember = votingBloc.manualMembers[manualMemberIndex];

      if (!manualMember) {
        return res.status(400).json({ message: 'Manual member not found in this voting bloc' });
      }

      // Remove manual member from the votingBlocMembers table
      const deleteQuery = `
        DELETE FROM "votingBlocMembers" 
        WHERE "votingBlocId" = $1 
          AND "firstName" = $2 
          AND "lastName" = $3 
          AND "phoneNumber" = $4
          AND "memberType" = 'manual'
      `;

      await query(deleteQuery, [
        id,
        manualMember.firstName,
        manualMember.lastName,
        manualMember.phoneNumber
      ]);

      // Update voting bloc member count
      const updateCountQuery = `
        UPDATE "votingBlocs" 
        SET "totalMembers" = (
          SELECT COUNT(*) FROM "votingBlocMembers" 
          WHERE "votingBlocId" = $1
        )
        WHERE id = $1
      `;
      await query(updateCountQuery, [id]);

      res.status(200).json({
        success: true,
        message: 'Manual member removed successfully',
      });

    } else {
      // Handle platform member removal (existing logic)
      // Check if member exists in the voting bloc
      if (!votingBloc.members.includes(memberId)) {
        return res.status(400).json({ message: 'User is not a member of this voting bloc' });
      }

      // Cannot remove the creator
      if (memberId === getId(votingBloc.creator)) {
        return res.status(400).json({ message: 'Cannot remove the creator from the voting bloc' });
      }

      // Get member and creator info for notifications
      const member = await User.findById(memberId);
      const creator = await User.findById(req.userId);

      if (!member || !creator) {
        return res.status(404).json({ message: 'User not found' });
      }

      // Remove member
      votingBloc.members = votingBloc.members.filter(
        member => getId(member) !== memberId
      );

      // Remove member metadata if it exists
      if (votingBloc.memberMetadata && Array.isArray(votingBloc.memberMetadata)) {
        votingBloc.memberMetadata = votingBloc.memberMetadata.filter(
          metadata => getId(metadata.userId) !== memberId
        );
      }

      await votingBloc.save();

      // Create in-app notification for the removed member
      try {
        // Use name field if available, otherwise construct from personalInfo
        const creatorName = creator.name ||
          (creator.personalInfo?.first_name && creator.personalInfo?.last_name
            ? `${creator.personalInfo.first_name} ${creator.personalInfo.last_name}`
            : creator.email);

        await Notification.create({
          userId: memberId,
          type: 'voting_bloc_removal',
          title: `Removed from "${votingBloc.name}"`,
          message: `You have been removed from the "${votingBloc.name}" voting bloc by ${creatorName}.${reason ? ` Reason: ${reason}` : ''}`,
          metadata: {
            votingBlocId: id,
            votingBlocName: votingBloc.name,
            creatorName: creatorName,
            reason: reason || null
          }
        });
      } catch (notificationError) {
        console.error('Error creating removal notification:', notificationError);
        // Don't fail the entire operation if notification fails
      }

      // Send email notification to the removed member
      try {
        if (member.email) {
          // Use name field if available, otherwise construct from personalInfo
          const memberName = member.name ||
            (member.personalInfo?.first_name && member.personalInfo?.last_name
              ? `${member.personalInfo.first_name} ${member.personalInfo.last_name}`
              : member.email);

          const creatorName = creator.name ||
            (creator.personalInfo?.first_name && creator.personalInfo?.last_name
              ? `${creator.personalInfo.first_name} ${creator.personalInfo.last_name}`
              : creator.email);

          await sendVotingBlocRemovalEmail(
            memberName,
            member.email,
            votingBloc.name,
            creatorName,
            reason
          );
        }
      } catch (emailError) {
        console.error('Error sending removal email:', emailError);
        // Don't fail the entire operation if email fails
      }

      res.status(200).json({
        success: true,
        message: 'Member removed successfully',
      });
    }
  } catch (error) {
    console.error('Error removing member:', error);
    res.status(500).json({ message: 'Server error' });
  }
};

// Get member engagement analytics
export const getMemberEngagement = async (req, res) => {
  try {
    const { id } = req.params;

    const votingBloc = await VotingBloc.findById(id, true); // includeDetails = true

    if (!votingBloc) {
      return res.status(404).json({ message: 'Voting bloc not found' });
    }

    // Check if user is the creator
    const isCreator = votingBloc.creator && votingBloc.creator.id === req.userId;
    if (!isCreator) {
      return res.status(403).json({ message: 'Only the creator can view member engagement' });
    }

    // Calculate engagement metrics
    const totalMembers = votingBloc.memberDetails.length;
    const pendingInvitations = votingBloc.invitations.filter(inv => inv.status === 'pending').length;
    const acceptedInvitations = votingBloc.invitations.filter(inv => inv.status === 'accepted').length;
    const declinedInvitations = votingBloc.invitations.filter(inv => inv.status === 'declined').length;

    // Recent activity (members who joined in last 30 days)
    const thirtyDaysAgo = new Date(Date.now() - 30 * 24 * 60 * 60 * 1000);
    const recentMembers = votingBloc.memberDetails.filter(member =>
      new Date(member.joinDate) > thirtyDaysAgo
    ).length;

    res.status(200).json({
      success: true,
      engagement: {
        totalMembers,
        recentMembers,
        pendingInvitations,
        acceptedInvitations,
        declinedInvitations,
        conversionRate: totalMembers > 0 ? ((acceptedInvitations / (acceptedInvitations + declinedInvitations)) * 100).toFixed(1) : 0,
        growthRate: votingBloc.monthlyGrowth || 0,
      },
      members: votingBloc.memberDetails,
      invitations: votingBloc.invitations,
    });
  } catch (error) {
    console.error('Error getting member engagement:', error);
    res.status(500).json({ message: 'Server error' });
  }
};

// Send private message to a member
export const sendPrivateMessage = async (req, res) => {
  try {
    const { id, memberId } = req.params;
    const { message } = req.body;
    const userId = req.userId;

    // Check if voting bloc exists and user is creator
    const votingBloc = await VotingBloc.findById(id);
    if (!votingBloc) {
      return res.status(404).json({ message: 'Voting bloc not found' });
    }

    if (getId(votingBloc.creator) !== userId) {
      return res.status(403).json({ message: 'Only the creator can send private messages' });
    }

    // Check if the member exists in the voting bloc
    const isMember = votingBloc.members.some(member => getId(member) === memberId);
    if (!isMember) {
      return res.status(404).json({ message: 'Member not found in this voting bloc' });
    }

    // Get member and sender details
    const [member, sender] = await Promise.all([
      User.findById(memberId),
      User.findById(userId)
    ]);

    if (!member || !sender) {
      return res.status(404).json({ message: 'User not found' });
    }

    // Save the private message
    const newMessage = await VotingBlocMessage.create({
      votingBlocId: id,
      fromUser: userId,
      toUser: memberId,
      message,
      messageType: 'private',
      status: 'sent'
    });

    // Create in-app notification for the recipient
    const notification = await Notification.create({
      recipient: memberId,
      type: "votingBlocMessage",
      title: `Private message from ${sender.name || sender.personalInfo?.user_name || 'Voting Bloc Creator'}`,
      message,
      relatedVotingBloc: votingBloc._id,
    });

    // Send email notification
    let emailSent = false;
    if (member.email) {
      try {
        await sendVotingBlocPrivateMessageEmail(
          votingBloc.name,
          sender.name || sender.personalInfo?.user_name || 'Voting Bloc Creator',
          member.name || member.personalInfo?.user_name || 'Member',
          member.email,
          message
        );
        emailSent = true;

        // Update message status to delivered
        newMessage.status = 'delivered';
        await newMessage.save();
      } catch (emailError) {
        console.error('Error sending private message email:', emailError);
        // Don't fail the request if email fails, but log it
      }
    }

    const messageData = {
      _id: newMessage._id,
      from: {
        _id: userId,
        name: sender.name || sender.personalInfo?.user_name || 'Voting Bloc Creator'
      },
      to: {
        _id: memberId,
        name: member.name || member.personalInfo?.user_name || 'Member',
        email: member.email
      },
      message,
      votingBloc: {
        _id: id,
        name: votingBloc.name
      },
      timestamp: newMessage.createdAt,
      status: newMessage.status,
      emailSent
    };

    res.status(200).json({
      success: true,
      message: 'Private message sent successfully',
      data: messageData,
      notification
    });
  } catch (error) {
    console.error('Error sending private message:', error);
    res.status(500).json({ message: 'Server error' });
  }
};

// Update member tags (decision and contact tags)
export const updateMemberTags = async (req, res) => {
  try {
    const { id, memberId } = req.params;
    const { decisionTag, contactTag, notes, engagementLevel, pvcStatus } = req.body;

    const votingBloc = await VotingBloc.findById(id, true); // Get full details
    if (!votingBloc) {
      return res.status(404).json({ message: 'Voting bloc not found' });
    }

    // Check if user is the creator
    const creatorId = typeof votingBloc.creator === 'object' ? votingBloc.creator.id : votingBloc.creator;
    if (creatorId !== req.userId) {
      return res.status(403).json({ message: 'Only the voting bloc creator can update member tags' });
    }

    // Check if it's a manual member (ID starts with 'manual_')
    if (memberId.startsWith('manual_')) {
      // Handle manual member update
      const manualMemberIndex = parseInt(memberId.split('_')[1]);
      const manualMember = votingBloc.manualMembers[manualMemberIndex];

      if (!manualMember) {
        return res.status(404).json({ message: 'Manual member not found' });
      }

      // Update manual member metadata in the votingBlocMembers table
      const updateQuery = `
        UPDATE "votingBlocMembers" 
        SET 
          "decisionTag" = COALESCE($1, "decisionTag"),
          "contactTag" = COALESCE($2, "contactTag"),
          "notes" = COALESCE($3, "notes"),
          "engagementLevel" = COALESCE($4, "engagementLevel"),
          "pvcStatus" = COALESCE($5, "pvcStatus"),
          "lastContactDate" = CASE WHEN $2 IS NOT NULL THEN NOW() ELSE "lastContactDate" END
        WHERE "votingBlocId" = $6 
          AND "firstName" = $7 
          AND "lastName" = $8 
          AND "phoneNumber" = $9
          AND "memberType" = 'manual'
      `;

      await query(updateQuery, [
        decisionTag,
        contactTag,
        notes,
        engagementLevel,
        pvcStatus,
        id,
        manualMember.firstName,
        manualMember.lastName,
        manualMember.phoneNumber
      ]);

    } else {
      // Handle platform member update (existing logic)
      // Check if the member exists in the voting bloc
      if (!votingBloc.members.includes(memberId)) {
        return res.status(404).json({ message: 'Member not found in this voting bloc' });
      }

      // Find or create member metadata
      let memberMeta = votingBloc.memberMetadata.find(meta => getId(meta.userId) === memberId);
      if (!memberMeta) {
        // Create new metadata if it doesn't exist
        votingBloc.memberMetadata.push({
          userId: memberId,
          joinDate: new Date(),
          decisionTag: decisionTag || 'Undecided',
          contactTag: contactTag || 'No Response',
          engagementLevel: engagementLevel || 'Medium',
          pvcStatus: pvcStatus || 'Unregistered',
          notes: notes || ''
        });
      } else {
        // Update existing metadata
        if (decisionTag) memberMeta.decisionTag = decisionTag;
        if (contactTag) {
          memberMeta.contactTag = contactTag;
          memberMeta.lastContactDate = new Date();
        }
        if (notes !== undefined) memberMeta.notes = notes;
        if (engagementLevel) memberMeta.engagementLevel = engagementLevel;
        if (pvcStatus) memberMeta.pvcStatus = pvcStatus;
      }

      await votingBloc.save();
    }

    res.status(200).json({
      success: true,
      message: 'Member tags updated successfully'
    });
  } catch (error) {
    console.error('Error updating member tags:', error);
    res.status(500).json({ message: 'Server error' });
  }
};

// Get member metadata for a voting bloc
export const getMemberMetadata = async (req, res) => {
  try {
    const { id } = req.params;

    const votingBloc = await VotingBloc.findById(id, true); // includeDetails = true

    if (!votingBloc) {
      return res.status(404).json({ message: 'Voting bloc not found' });
    }

    // Check if user is the creator or a member
    const isCreator = votingBloc.creator && votingBloc.creator.id === req.userId;
    const isMember = votingBloc.members && votingBloc.members.includes(req.userId);

    if (!isCreator && !isMember) {
      return res.status(403).json({ message: 'Access denied' });
    }

    // Combine platform members with metadata
    const platformMembersWithMetadata = votingBloc.memberDetails.map(member => {
      const metadata = votingBloc.memberMetadata.find(meta => meta.userId === member.userId);
      return {
        _id: member.userId,
        name: member.name,
        email: member.email,
        phone: member.phone,
        countryCode: member.countryCode,
        isManualMember: false,
        metadata: metadata || {
          joinDate: member.joinDate || new Date(),
          decisionTag: 'Undecided',
          contactTag: 'No Response',
          engagementLevel: 'Medium',
          notes: '',
          lastContactDate: null,
          location: {}
        }
      };
    });

    // Add manual members with their own structure
    const manualMembersWithMetadata = (votingBloc.manualMembers || []).map((manualMember, index) => ({
      _id: `manual_${index}_${Date.parse(manualMember.addedAt)}`,
      name: `${manualMember.firstName} ${manualMember.lastName}`.trim(),
      email: null,
      phone: manualMember.phoneNumber,
      countryCode: null,
      isManualMember: true,
      metadata: {
        joinDate: manualMember.addedAt || new Date(),
        decisionTag: manualMember.decisionTag || 'Undecided',
        contactTag: manualMember.contactTag || 'No Response',
        engagementLevel: manualMember.engagementLevel || 'Medium',
        pvcStatus: manualMember.pvcStatus || 'Unregistered',
        notes: manualMember.notes || '',
        lastContactDate: manualMember.lastContactDate,
        location: {
          state: manualMember.state,
          lga: manualMember.lga,
          ward: manualMember.ward
        },
        memberType: 'manual'
      }
    }));

    // Combine both types of members
    const allMembersWithMetadata = [...platformMembersWithMetadata, ...manualMembersWithMetadata];

    res.status(200).json({
      success: true,
      members: allMembersWithMetadata
    });
  } catch (error) {
    console.error('Error fetching member metadata:', error);
    res.status(500).json({ message: 'Server error' });
  }
};

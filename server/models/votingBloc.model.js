import { query, getClient } from '../config/db.js';

class VotingBloc {
  constructor(votingBlocData) {
    Object.assign(this, votingBlocData);

    // Ensure memberCount and totalMembers are numbers
    if (this.memberCount !== undefined) {
      this.memberCount = parseInt(this.memberCount) || 0;
    }
    if (this.totalMembers !== undefined) {
      this.totalMembers = parseInt(this.totalMembers) || 0;
    }

    // If memberCount is available but totalMembers is not, sync them
    if (this.memberCount !== undefined && this.totalMembers === undefined) {
      this.totalMembers = this.memberCount;
    }
    if (this.totalMembers !== undefined && this.memberCount === undefined) {
      this.memberCount = this.totalMembers;
    }
  }

  // Create a new voting bloc
  static async create(votingBlocData) {
    console.log('ðŸ—ï¸ VotingBloc.create called with data:', {
      name: votingBlocData.name,
      creator: votingBlocData.creator,
      joinCode: votingBlocData.joinCode,
      isAutoGenerated: votingBlocData.isAutoGenerated
    });

    const {
      name,
      description,
      goals = [],
      targetCandidate,
      scope,
      locationState,
      locationLga,
      locationWard,
      bannerImageUrl = '',
      richDescription = '',
      joinCode,
      creator,
      toolkits = [],
      status = 'active',
      isAutoGenerated = false
    } = votingBlocData;

    console.log('ðŸ“ Extracted voting bloc fields:', {
      name,
      creator,
      scope,
      locationState,
      locationLga,
      locationWard,
      isAutoGenerated
    });

    const client = await getClient();
    try {
      await client.query('BEGIN');
      console.log('ðŸ”„ Database transaction started');

      // Insert main voting bloc record
      console.log('ðŸ’¾ Inserting voting bloc into database...');
      const votingBlocResult = await client.query(
        `INSERT INTO "votingBlocs" (
          name, description, goals, "targetCandidate", scope,
          "locationState", "locationLga", "locationWard",
          "bannerImageUrl", "richDescription", "joinCode", creator, status, "isAutoGenerated"
        ) VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14) 
        RETURNING *`,
        [name, description, goals, targetCandidate, scope, locationState, locationLga, locationWard, bannerImageUrl, richDescription, joinCode, creator, status, isAutoGenerated]
      );

      const votingBloc = votingBlocResult.rows[0];
      console.log('âœ… Voting bloc inserted with ID:', votingBloc.id);

      // Insert toolkits if provided
      if (toolkits && toolkits.length > 0) {
        console.log(`ðŸ“š Inserting ${toolkits.length} toolkits...`);
        for (const toolkit of toolkits) {
          await client.query(
            `INSERT INTO "votingBlocToolkits" ("votingBlocId", label, url, type) 
             VALUES ($1, $2, $3, $4)`,
            [votingBloc.id, toolkit.label, toolkit.url, toolkit.type]
          );
        }
        console.log('âœ… Toolkits inserted successfully');
      }

      await client.query('COMMIT');
      console.log('âœ… Transaction committed successfully');

      const createdVotingBloc = new VotingBloc(votingBloc);
      console.log('ðŸŽ‰ VotingBloc created and returned:', {
        id: createdVotingBloc.id,
        name: createdVotingBloc.name,
        creator: createdVotingBloc.creator
      });

      return createdVotingBloc;
    } catch (error) {
      await client.query('ROLLBACK');
      console.error('âŒ Error in VotingBloc.create:', {
        error: error.message,
        stack: error.stack,
        votingBlocData: { name, creator, joinCode }
      });
      throw error;
    } finally {
      client.release();
    }
  }

  // Find voting bloc by ID with full details
  static async findById(id, includeDetails = true) {
    if (!includeDetails) {
      const result = await query('SELECT * FROM "votingBlocs" WHERE id = $1', [id]);
      return result.rows.length > 0 ? new VotingBloc(result.rows[0]) : null;
    }

    const client = await getClient();
    try {
      // Get main voting bloc data
      const votingBlocResult = await client.query('SELECT * FROM "votingBlocs" WHERE id = $1', [id]);

      if (votingBlocResult.rows.length === 0) return null;

      const votingBloc = votingBlocResult.rows[0];

      // Get toolkits
      const toolkitsResult = await client.query(
        'SELECT * FROM "votingBlocToolkits" WHERE "votingBlocId" = $1 ORDER BY "createdAt"',
        [id]
      );

      // Get members (both platform and manual)
      const membersResult = await client.query(
        `SELECT 
          vm."userId", 
          vm."joinDate", 
          vm."memberType",
          vm."firstName",
          vm."lastName",
          vm."phoneNumber",
          vm."state",
          vm."lga", 
          vm."ward",
          vm."decisionTag",
          vm."contactTag",
          vm."lastContactDate",
          vm."engagementLevel",
          vm."pvcStatus",
          vm."notes",
          u.name as "platformName", 
          u.email, 
          u.phone,
          u."countryCode"
         FROM "votingBlocMembers" vm
         LEFT JOIN users u ON vm."userId" = u.id AND vm."memberType" = 'platform'
         WHERE vm."votingBlocId" = $1 
         ORDER BY vm."joinDate"`,
        [id]
      );

      // Get member metadata
      const metadataResult = await client.query(
        'SELECT * FROM "votingBlocMemberMetadata" WHERE "votingBlocId" = $1',
        [id]
      );

      // Get invitations
      const invitationsResult = await client.query(
        `SELECT vi.*, u1.name as "invitedByName", u2.name as "invitedUserName"
         FROM "votingBlocInvitations" vi
         LEFT JOIN users u1 ON vi."invitedBy" = u1.id
         LEFT JOIN users u2 ON vi."invitedUser" = u2.id
         WHERE vi."votingBlocId" = $1 
         ORDER BY vi."inviteDate" DESC`,
        [id]
      );

      // Get creator information
      const creatorResult = await client.query(
        'SELECT id, name, email, "profileImage" FROM users WHERE id = $1',
        [votingBloc.creator]
      );

      // Attach related data
      votingBloc.toolkits = toolkitsResult.rows;

      // Process members to handle both platform and manual members
      votingBloc.members = [];
      votingBloc.memberDetails = [];
      votingBloc.manualMembers = [];

      membersResult.rows.forEach(row => {
        if (row.memberType === 'manual') {
          // Manual member with metadata
          const manualMember = {
            id: row.userId || `manual_${row.joinDate}`, // Use a unique identifier
            firstName: row.firstName,
            lastName: row.lastName,
            phoneNumber: row.phoneNumber,
            state: row.state,
            lga: row.lga,
            ward: row.ward,
            addedAt: row.joinDate,
            decisionTag: row.decisionTag,
            contactTag: row.contactTag,
            lastContactDate: row.lastContactDate,
            engagementLevel: row.engagementLevel,
            pvcStatus: row.pvcStatus,
            notes: row.notes
          };
          votingBloc.manualMembers.push(manualMember);
        } else {
          // Platform member
          if (row.userId) {
            votingBloc.members.push(row.userId);
            votingBloc.memberDetails.push({
              userId: row.userId,
              name: row.platformName,
              email: row.email,
              phone: row.phone, // Use phone from users table, not phoneNumber from manual members
              countryCode: row.countryCode,
              joinDate: row.joinDate
            });
          }
        }
      });

      // Transform member metadata to match expected format
      votingBloc.memberMetadata = metadataResult.rows.map(row => ({
        userId: row.userId,
        joinDate: row.joinDate,
        decisionTag: row.decisionTag,
        contactTag: row.contactTag,
        lastContactDate: row.lastContactDate,
        engagementLevel: row.engagementLevel,
        pvcStatus: row.pvcStatus,
        notes: row.notes,
        location: {
          state: row.memberLocationState || '',
          lga: row.memberLocationLga || '',
          ward: row.memberLocationWard || ''
        }
      }));

      votingBloc.invitations = invitationsResult.rows;

      // Populate creator as an object
      if (creatorResult.rows.length > 0) {
        votingBloc.creator = creatorResult.rows[0];
      }

      // Update metrics
      const totalPlatformMembers = votingBloc.members.length;
      const totalManualMembers = votingBloc.manualMembers.length;
      const totalMembers = totalPlatformMembers + totalManualMembers;

      votingBloc.totalMembers = totalMembers;
      votingBloc.memberCount = totalMembers;
      votingBloc.platformMemberCount = totalPlatformMembers;
      votingBloc.manualMemberCount = totalManualMembers;

      return new VotingBloc(votingBloc);
    } finally {
      client.release();
    }
  }

  // Find voting blocs by creator
  static async findByCreator(creatorId, options = {}) {
    console.log(`ðŸ” VotingBloc.findByCreator called for creator: ${creatorId}`);
    const { limit = 20, offset = 0, includeDetails = false } = options;

    if (!includeDetails) {
      console.log('ðŸ“‹ Fetching voting blocs without details...');
      const result = await query(
        'SELECT * FROM "votingBlocs" WHERE creator = $1 ORDER BY "createdAt" DESC LIMIT $2 OFFSET $3',
        [creatorId, limit, offset]
      );
      console.log(`âœ… Found ${result.rows.length} voting blocs (simple query)`);
      return result.rows.map(row => new VotingBloc(row));
    }

    // Get with member counts and creator info
    console.log('ðŸ“‹ Fetching voting blocs with member counts and creator details...');
    const result = await query(
      `SELECT vb.*, COUNT(vm."userId") as "memberCount", 
              u.id as "creatorId", u.name as "creatorName", u.email as "creatorEmail"
       FROM "votingBlocs" vb
       LEFT JOIN "votingBlocMembers" vm ON vb.id = vm."votingBlocId"
       LEFT JOIN users u ON vb.creator = u.id
       WHERE vb.creator = $1
       GROUP BY vb.id, u.id, u.name, u.email
       ORDER BY vb."createdAt" DESC 
       LIMIT $2 OFFSET $3`,
      [creatorId, limit, offset]
    );

    console.log(`âœ… Found ${result.rows.length} voting blocs (detailed query)`);
    result.rows.forEach((row, index) => {
      console.log(`  ${index + 1}. "${row.name}" (ID: ${row.id}, Members: ${row.memberCount}, isAutoGenerated: ${row.isAutoGenerated})`);
    });

    return result.rows.map(row => {
      // Create a copy of the row and set creator as an object
      const votingBlocData = { ...row };
      votingBlocData.creator = {
        id: row.creatorId,
        name: row.creatorName,
        email: row.creatorEmail
      };

      // Remove the flat creator fields
      delete votingBlocData.creatorId;
      delete votingBlocData.creatorName;
      delete votingBlocData.creatorEmail;

      return new VotingBloc(votingBlocData);
    });
  }

  // Find voting bloc by join code
  static async findByJoinCode(joinCode) {
    // First get the basic voting bloc data
    const result = await query('SELECT * FROM "votingBlocs" WHERE "joinCode" = $1', [joinCode]);

    if (result.rows.length === 0) {
      return null;
    }

    // Use findById with includeDetails to get all related data
    return await VotingBloc.findById(result.rows[0].id, true);
  }

  // Search voting blocs
  static async search(searchOptions = {}) {
    const {
      query: searchQuery,
      scope,
      locationState,
      locationLga,
      status = 'active',
      limit = 20,
      offset = 0
    } = searchOptions;

    let whereClause = 'WHERE status = $1';
    let values = [status];
    let paramCount = 2;

    if (searchQuery) {
      whereClause += ` AND (name ILIKE $${paramCount} OR description ILIKE $${paramCount})`;
      values.push(`%${searchQuery}%`);
      paramCount++;
    }

    if (scope) {
      whereClause += ` AND scope = $${paramCount}`;
      values.push(scope);
      paramCount++;
    }

    if (locationState) {
      whereClause += ` AND "locationState" = $${paramCount}`;
      values.push(locationState);
      paramCount++;
    }

    if (locationLga) {
      whereClause += ` AND "locationLga" = $${paramCount}`;
      values.push(locationLga);
      paramCount++;
    }

    const result = await query(
      `SELECT vb.*, COUNT(vm."userId") as "memberCount",
              u.id as "creatorId", u.name as "creatorName", u.email as "creatorEmail"
       FROM "votingBlocs" vb
       LEFT JOIN "votingBlocMembers" vm ON vb.id = vm."votingBlocId"
       LEFT JOIN users u ON vb.creator = u.id
       ${whereClause}
       GROUP BY vb.id, u.id, u.name, u.email
       ORDER BY COUNT(vm."userId") DESC, vb."createdAt" DESC 
       LIMIT $${paramCount} OFFSET $${paramCount + 1}`,
      [...values, limit, offset]
    );

    return result.rows.map(row => {
      // Create a copy of the row and set creator as an object
      const votingBlocData = { ...row };
      votingBlocData.creator = {
        id: row.creatorId,
        name: row.creatorName,
        email: row.creatorEmail,
        personalInfo: {
          user_name: row.creatorName || 'Unknown User'
        }
      };

      // Remove the flat creator fields
      delete votingBlocData.creatorId;
      delete votingBlocData.creatorName;
      delete votingBlocData.creatorEmail;

      return new VotingBloc(votingBlocData);
    });
  }

  // Optimized search for leaderboard with profile images
  static async searchForLeaderboard(searchOptions = {}) {
    const {
      query: searchQuery,
      scope,
      locationState,
      locationLga,
      locationWard,
      status = 'active',
      limit = 100,
      offset = 0
    } = searchOptions;

    let whereClause = 'WHERE vb.status = $1';
    let values = [status];
    let paramCount = 2;

    if (searchQuery) {
      whereClause += ` AND (vb.name ILIKE $${paramCount} OR vb.description ILIKE $${paramCount})`;
      values.push(`%${searchQuery}%`);
      paramCount++;
    }

    if (scope) {
      whereClause += ` AND vb.scope = $${paramCount}`;
      values.push(scope);
      paramCount++;
    }

    if (locationState) {
      whereClause += ` AND vb."locationState" = $${paramCount}`;
      values.push(locationState);
      paramCount++;
    }

    if (locationLga) {
      whereClause += ` AND vb."locationLga" = $${paramCount}`;
      values.push(locationLga);
      paramCount++;
    }

    if (locationWard) {
      whereClause += ` AND vb."locationWard" = $${paramCount}`;
      values.push(locationWard);
      paramCount++;
    }

    // Optimized query using pre-aggregated member counts and including profile images
    const result = await query(
      `WITH MemberCounts AS (
         SELECT 
           "votingBlocId",
           COUNT("userId") as "memberCount"
         FROM "votingBlocMembers"
         GROUP BY "votingBlocId"
       )
       SELECT 
         vb.*,
         COALESCE(mc."memberCount", 0) as "memberCount",
         u.id as "creatorId",
         u.name as "creatorName", 
         u.email as "creatorEmail",
         u."profileImage" as "creatorProfileImage"
       FROM "votingBlocs" vb
       LEFT JOIN MemberCounts mc ON vb.id = mc."votingBlocId"
       LEFT JOIN users u ON vb.creator = u.id
       ${whereClause}
       ORDER BY COALESCE(mc."memberCount", 0) DESC, vb."createdAt" DESC 
       LIMIT $${paramCount} OFFSET $${paramCount + 1}`,
      [...values, limit, offset]
    );

    return result.rows.map(row => {
      // Create a copy of the row and set creator as an object with profile image
      const votingBlocData = { ...row };
      votingBlocData.creator = {
        id: row.creatorId,
        name: row.creatorName,
        email: row.creatorEmail,
        profileImage: row.creatorProfileImage,
        personalInfo: {
          user_name: row.creatorName || 'Unknown User'
        }
      };

      // Remove the flat creator fields
      delete votingBlocData.creatorId;
      delete votingBlocData.creatorName;
      delete votingBlocData.creatorEmail;
      delete votingBlocData.creatorProfileImage;

      return new VotingBloc(votingBlocData);
    });
  }

  // Add member to voting bloc
  static async addMember(votingBlocId, userId, metadata = {}) {
    const client = await getClient();
    try {
      await client.query('BEGIN');

      // Add to members table
      await client.query(
        `INSERT INTO "votingBlocMembers" ("votingBlocId", "userId") 
         VALUES ($1, $2) 
         ON CONFLICT ("votingBlocId", "userId") DO NOTHING`,
        [votingBlocId, userId]
      );

      // Add/update metadata
      const {
        decisionTag = 'Undecided',
        contactTag = 'No Response',
        engagementLevel = 'Medium',
        pvcStatus = 'Unregistered',
        notes = '',
        memberLocationState,
        memberLocationLga,
        memberLocationWard
      } = metadata;

      await client.query(
        `INSERT INTO "votingBlocMemberMetadata" (
          "votingBlocId", "userId", "decisionTag", "contactTag", "engagementLevel", "pvcStatus", notes,
          "memberLocationState", "memberLocationLga", "memberLocationWard"
        ) VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10)
        ON CONFLICT ("votingBlocId", "userId") 
        DO UPDATE SET
          "decisionTag" = EXCLUDED."decisionTag",
          "contactTag" = EXCLUDED."contactTag",
          "engagementLevel" = EXCLUDED."engagementLevel",
          "pvcStatus" = EXCLUDED."pvcStatus",
          notes = EXCLUDED.notes,
          "memberLocationState" = EXCLUDED."memberLocationState",
          "memberLocationLga" = EXCLUDED."memberLocationLga",
          "memberLocationWard" = EXCLUDED."memberLocationWard",
          "updatedAt" = NOW()`,
        [votingBlocId, userId, decisionTag, contactTag, engagementLevel, pvcStatus, notes, memberLocationState, memberLocationLga, memberLocationWard]
      );

      // Update member count
      const countResult = await client.query(
        'SELECT COUNT(*) as count FROM "votingBlocMembers" WHERE "votingBlocId" = $1',
        [votingBlocId]
      );

      await client.query(
        'UPDATE "votingBlocs" SET "totalMembers" = $1, "metricsLastUpdated" = NOW() WHERE id = $2',
        [parseInt(countResult.rows[0].count), votingBlocId]
      );

      await client.query('COMMIT');
      return true;
    } catch (error) {
      await client.query('ROLLBACK');
      throw error;
    } finally {
      client.release();
    }
  }

  // Remove member from voting bloc
  static async removeMember(votingBlocId, userId) {
    const client = await getClient();
    try {
      await client.query('BEGIN');

      // Remove from members and metadata
      await client.query(
        'DELETE FROM "votingBlocMembers" WHERE "votingBlocId" = $1 AND "userId" = $2',
        [votingBlocId, userId]
      );

      await client.query(
        'DELETE FROM "votingBlocMemberMetadata" WHERE "votingBlocId" = $1 AND "userId" = $2',
        [votingBlocId, userId]
      );

      // Update member count
      const countResult = await client.query(
        'SELECT COUNT(*) as count FROM "votingBlocMembers" WHERE "votingBlocId" = $1',
        [votingBlocId]
      );

      await client.query(
        'UPDATE "votingBlocs" SET "totalMembers" = $1, "metricsLastUpdated" = NOW() WHERE id = $2',
        [parseInt(countResult.rows[0].count), votingBlocId]
      );

      await client.query('COMMIT');
      return true;
    } catch (error) {
      await client.query('ROLLBACK');
      throw error;
    } finally {
      client.release();
    }
  }

  // Create invitation
  static async createInvitation(invitationData) {
    const {
      votingBlocId,
      invitedBy,
      invitedUser,
      invitedEmail,
      inviteType = 'email',
      message
    } = invitationData;

    const result = await query(
      `INSERT INTO "votingBlocInvitations" (
        "votingBlocId", "invitedBy", "invitedUser", "invitedEmail", "inviteType", message
      ) VALUES ($1, $2, $3, $4, $5, $6) 
      RETURNING *`,
      [votingBlocId, invitedBy, invitedUser, invitedEmail, inviteType, message]
    );

    return result.rows[0];
  }

  // Accept invitation
  static async acceptInvitation(invitationId, userId) {
    const client = await getClient();
    try {
      await client.query('BEGIN');

      // Update invitation status
      const invitationResult = await client.query(
        `UPDATE "votingBlocInvitations" 
         SET status = 'accepted', "responseDate" = NOW(), "updatedAt" = NOW()
         WHERE id = $1 
         RETURNING "votingBlocId"`,
        [invitationId]
      );

      if (invitationResult.rows.length === 0) {
        throw new Error('Invitation not found');
      }

      const votingBlocId = invitationResult.rows[0].votingBlocId;

      // Add user as member
      await VotingBloc.addMember(votingBlocId, userId);

      await client.query('COMMIT');
      return votingBlocId;
    } catch (error) {
      await client.query('ROLLBACK');
      throw error;
    } finally {
      client.release();
    }
  }

  // Update voting bloc
  static async findByIdAndUpdate(id, updateData) {
    const client = await getClient();
    try {
      await client.query('BEGIN');

      // Update main voting bloc data
      const updateFields = [];
      const values = [];
      let paramCount = 1;

      const updatableFields = [
        'name', 'description', 'goals', 'targetCandidate', 'scope',
        'locationState', 'locationLga', 'locationWard', 'bannerImageUrl',
        'richDescription', 'status'
      ];

      updatableFields.forEach(field => {
        if (updateData[field] !== undefined) {
          updateFields.push(`"${field}" = $${paramCount}`);
          values.push(updateData[field]);
          paramCount++;
        }
      });

      if (updateFields.length > 0) {
        updateFields.push(`"updatedAt" = NOW()`);
        values.push(id);

        const updateQuery = `
          UPDATE "votingBlocs" 
          SET ${updateFields.join(', ')} 
          WHERE id = $${paramCount}
          RETURNING *
        `;

        await client.query(updateQuery, values);
      }

      // Update toolkits if provided
      if (updateData.toolkits) {
        // Remove existing toolkits
        await client.query('DELETE FROM "votingBlocToolkits" WHERE "votingBlocId" = $1', [id]);

        // Add new toolkits
        for (const toolkit of updateData.toolkits) {
          await client.query(
            `INSERT INTO "votingBlocToolkits" ("votingBlocId", label, url, type) 
             VALUES ($1, $2, $3, $4)`,
            [id, toolkit.label, toolkit.url, toolkit.type]
          );
        }
      }

      await client.query('COMMIT');
      return await VotingBloc.findById(id);
    } catch (error) {
      await client.query('ROLLBACK');
      throw error;
    } finally {
      client.release();
    }
  }

  // Delete voting bloc
  static async deleteById(id) {
    const result = await query(
      'DELETE FROM "votingBlocs" WHERE id = $1 RETURNING *',
      [id]
    );

    return result.rows.length > 0 ? new VotingBloc(result.rows[0]) : null;
  }

  // Get voting blocs with pagination
  static async findAll(options = {}) {
    const { limit = 20, offset = 0, status = 'active', orderBy = 'createdAt', orderDirection = 'DESC' } = options;

    const result = await query(
      `SELECT vb.*, COUNT(vm."userId") as "memberCount"
       FROM "votingBlocs" vb
       LEFT JOIN "votingBlocMembers" vm ON vb.id = vm."votingBlocId"
       WHERE vb.status = $1
       GROUP BY vb.id
       ORDER BY vb."${orderBy}" ${orderDirection}
       LIMIT $2 OFFSET $3`,
      [status, limit, offset]
    );

    return result.rows.map(row => new VotingBloc(row));
  }

  // Instance method to save changes
  async save() {
    const client = await getClient();

    try {
      await client.query('BEGIN');

      // Update main voting bloc fields
      const updateFields = [];
      const values = [];
      let paramCount = 1;

      const updatableFields = [
        'name', 'description', 'goals', 'targetCandidate', 'scope',
        'locationState', 'locationLga', 'locationWard', 'bannerImageUrl',
        'richDescription', 'totalMembers', 'weeklyGrowth', 'monthlyGrowth',
        'engagementScore', 'status'
      ];

      updatableFields.forEach(field => {
        if (this[field] !== undefined) {
          updateFields.push(`"${field}" = $${paramCount}`);
          values.push(this[field]);
          paramCount++;
        }
      });

      if (updateFields.length > 0) {
        updateFields.push(`"updatedAt" = NOW()`);
        values.push(this.id);

        const updateQuery = `
          UPDATE "votingBlocs" 
          SET ${updateFields.join(', ')} 
          WHERE id = $${paramCount}
          RETURNING *
        `;

        const result = await client.query(updateQuery, values);
        Object.assign(this, result.rows[0]);
      }

      // Update members if they exist
      if (this.members && Array.isArray(this.members)) {
        // Delete existing members for this voting bloc
        await client.query(
          'DELETE FROM "votingBlocMembers" WHERE "votingBlocId" = $1',
          [this.id]
        );

        // Insert new/updated members
        for (const memberId of this.members) {
          await client.query(
            `INSERT INTO "votingBlocMembers" ("votingBlocId", "userId", "joinDate") 
             VALUES ($1, $2, NOW())`,
            [this.id, memberId]
          );
        }
      }

      // Update member metadata if it exists
      if (this.memberMetadata && Array.isArray(this.memberMetadata)) {
        // Delete existing metadata for this voting bloc
        await client.query(
          'DELETE FROM "votingBlocMemberMetadata" WHERE "votingBlocId" = $1',
          [this.id]
        );

        // Insert new/updated metadata
        for (const metadata of this.memberMetadata) {
          await client.query(
            `INSERT INTO "votingBlocMemberMetadata" (
              "votingBlocId", "userId", "joinDate", "decisionTag", "contactTag", 
              "engagementLevel", "pvcStatus", "notes", "lastContactDate", "memberLocationState", 
              "memberLocationLga", "memberLocationWard"
            ) VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12)`,
            [
              this.id,
              metadata.userId,
              metadata.joinDate || new Date(),
              metadata.decisionTag || 'Undecided',
              metadata.contactTag || 'No Response',
              metadata.engagementLevel || 'Medium',
              metadata.pvcStatus || 'Unregistered',
              metadata.notes || '',
              metadata.lastContactDate || null,
              metadata.location?.state || '',
              metadata.location?.lga || '',
              metadata.location?.ward || ''
            ]
          );
        }
      }

      // Update invitations if they exist
      if (this.invitations && Array.isArray(this.invitations)) {
        // Delete existing invitations for this voting bloc
        await client.query(
          'DELETE FROM "votingBlocInvitations" WHERE "votingBlocId" = $1',
          [this.id]
        );

        // Insert new/updated invitations
        for (const invitation of this.invitations) {
          await client.query(
            `INSERT INTO "votingBlocInvitations" (
              "votingBlocId", "invitedBy", "invitedUser", "invitedEmail", 
              "inviteType", "status", "message", "inviteDate", "responseDate"
            ) VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9)`,
            [
              this.id,
              invitation.invitedBy,
              invitation.invitedUser || null,
              invitation.invitedEmail || null,
              invitation.inviteType || 'email',
              invitation.status || 'pending',
              invitation.message || '',
              invitation.inviteDate || new Date(),
              invitation.responseDate || null
            ]
          );
        }
      }

      await client.query('COMMIT');
      return this;
    } catch (error) {
      await client.query('ROLLBACK');
      throw error;
    } finally {
      client.release();
    }
  }

  // Convert to plain object (like Mongoose toObject)
  toObject() {
    return { ...this };
  }

}

export default VotingBloc;

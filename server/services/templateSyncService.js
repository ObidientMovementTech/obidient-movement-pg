import { query, getClient } from '../config/db.js';
import DefaultVotingBlocSettings from '../models/defaultVotingBlocSettings.model.js';

class TemplateSyncService {
  /**
   * Check if auto-generated voting blocs need to be synced with template updates
   */
  static async checkForOutdatedBlocs() {
    try {
      const defaultSettings = await DefaultVotingBlocSettings.get();
      const currentTemplateVersion = defaultSettings.templateVersion || 1;

      const result = await query(`
        SELECT id, name, "templateVersion", creator
        FROM "votingBlocs" 
        WHERE "isAutoGenerated" = true 
        AND ("templateVersion" IS NULL OR "templateVersion" < $1)
      `, [currentTemplateVersion]);

      return {
        outdatedCount: result.rows.length,
        outdatedBlocs: result.rows,
        currentTemplateVersion
      };
    } catch (error) {
      console.error('Error checking for outdated blocs:', error);
      throw error;
    }
  }

  /**
   * Sync a single voting bloc with the latest template
   */
  static async syncVotingBloc(votingBlocId, syncFields = null) {
    const client = await getClient();

    try {
      await client.query('BEGIN');

      // Get the voting bloc
      const blocResult = await client.query(
        'SELECT * FROM "votingBlocs" WHERE id = $1 AND "isAutoGenerated" = true',
        [votingBlocId]
      );

      if (blocResult.rows.length === 0) {
        throw new Error('Auto-generated voting bloc not found');
      }

      const votingBloc = blocResult.rows[0];
      const oldTemplateVersion = votingBloc.templateVersion || 1;

      // Get current default settings
      const defaultSettings = await DefaultVotingBlocSettings.get();
      const newTemplateVersion = defaultSettings.templateVersion || 1;

      if (oldTemplateVersion >= newTemplateVersion) {
        console.log(`Voting bloc ${votingBlocId} is already up to date`);
        await client.query('ROLLBACK');
        return { updated: false, reason: 'Already up to date' };
      }

      // Determine sync preferences
      let syncPreferences;

      if (syncFields && syncFields.length > 0) {
        // Use provided sync fields
        syncPreferences = {
          toolkits: syncFields.includes('toolkits'),
          location: syncFields.includes('location'),
          scope: syncFields.includes('scope'),
          goals: syncFields.includes('goals'),
          description: syncFields.includes('description'),
          richDescription: syncFields.includes('richDescription'),
          bannerImage: syncFields.includes('bannerImage'),
          targetCandidate: syncFields.includes('targetCandidate')
        };
      } else {
        // Default: sync ALL fields for complete template synchronization
        syncPreferences = {
          toolkits: true,
          location: true,
          scope: true,
          goals: true,
          description: true,
          richDescription: true,
          bannerImage: true,
          targetCandidate: true
        };
      }

      // Override with specific fields if provided
      if (syncFields) {
        console.log('ðŸ”§ Sync fields provided:', syncFields);
        console.log('ðŸ”§ Original sync preferences:', syncPreferences);
        Object.keys(syncPreferences).forEach(key => {
          if (syncFields.includes(key)) {
            syncPreferences[key] = true;
          } else {
            syncPreferences[key] = false;
          }
        });
        console.log('ðŸ”§ Final sync preferences:', syncPreferences);
      }

      const updateFields = [];
      const updateValues = [];
      let paramIndex = 1;
      const changesSummary = [];

      // Sync toolkits
      if (syncPreferences.toolkits && defaultSettings.toolkits) {
        // Delete existing toolkits
        await client.query('DELETE FROM "votingBlocToolkits" WHERE "votingBlocId" = $1', [votingBlocId]);

        // Insert new toolkits from template
        for (const toolkit of defaultSettings.toolkits) {
          await client.query(
            `INSERT INTO "votingBlocToolkits" ("votingBlocId", label, url, type) 
             VALUES ($1, $2, $3, $4)`,
            [votingBlocId, toolkit.label, toolkit.url, toolkit.type]
          );
        }

        changesSummary.push(`Updated ${defaultSettings.toolkits.length} toolkits`);
      }

      // Sync location defaults
      if (syncPreferences.location && defaultSettings.locationDefaults) {
        const locationDefaults = defaultSettings.locationDefaults;

        if (locationDefaults.defaultState && !locationDefaults.useUserLocation) {
          updateFields.push(`"locationState" = $${paramIndex++}`);
          updateValues.push(locationDefaults.defaultState);
          changesSummary.push('Updated location state');
        }

        if (locationDefaults.defaultLga && !locationDefaults.useUserLocation) {
          updateFields.push(`"locationLga" = $${paramIndex++}`);
          updateValues.push(locationDefaults.defaultLga);
          changesSummary.push('Updated location LGA');
        }

        if (locationDefaults.defaultWard && !locationDefaults.useUserLocation) {
          updateFields.push(`"locationWard" = $${paramIndex++}`);
          updateValues.push(locationDefaults.defaultWard);
          changesSummary.push('Updated location ward');
        }
      }

      // Sync scope
      if (syncPreferences.scope && defaultSettings.scope) {
        updateFields.push(`scope = $${paramIndex++}`);
        updateValues.push(defaultSettings.scope);
        changesSummary.push('Updated scope');
      }

      // Sync goals (optional)
      if (syncPreferences.goals && defaultSettings.goals) {
        updateFields.push(`goals = $${paramIndex++}`);
        // For PostgreSQL ARRAY column, pass the array directly
        let goalsValue;
        if (Array.isArray(defaultSettings.goals)) {
          goalsValue = defaultSettings.goals;
        } else if (typeof defaultSettings.goals === 'string') {
          // Try to parse as JSON array first
          try {
            const parsed = JSON.parse(defaultSettings.goals);
            goalsValue = Array.isArray(parsed) ? parsed : [defaultSettings.goals];
          } catch (e) {
            // If not JSON, treat as single goal
            goalsValue = [defaultSettings.goals];
          }
        } else {
          // Single goal value, wrap in array
          goalsValue = [String(defaultSettings.goals)];
        }
        updateValues.push(goalsValue);
        changesSummary.push('Updated goals');
      }

      // Sync description (optional)
      if (syncPreferences.description && defaultSettings.descriptionTemplate) {
        updateFields.push(`description = $${paramIndex++}`);
        updateValues.push(defaultSettings.descriptionTemplate);
        changesSummary.push('Updated description');
      }

      // Sync rich description template (optional)
      if (syncPreferences.richDescription && defaultSettings.richDescriptionTemplate) {
        updateFields.push(`"richDescription" = $${paramIndex++}`);
        updateValues.push(defaultSettings.richDescriptionTemplate);
        changesSummary.push('Updated rich description');
      }

      // Sync banner image
      if (syncPreferences.bannerImage && defaultSettings.bannerImageUrl !== undefined) {
        updateFields.push(`"bannerImageUrl" = $${paramIndex++}`);
        updateValues.push(defaultSettings.bannerImageUrl || null);
        changesSummary.push('Updated banner image');
      }

      // Sync target candidate
      if (syncPreferences.targetCandidate && defaultSettings.targetCandidate) {
        updateFields.push(`"targetCandidate" = $${paramIndex++}`);
        updateValues.push(defaultSettings.targetCandidate);
        changesSummary.push('Updated target candidate');
      }

      // Update template version and sync timestamp
      updateFields.push(`"templateVersion" = $${paramIndex++}`);
      updateValues.push(newTemplateVersion);

      updateFields.push(`"lastSyncedAt" = $${paramIndex++}`);
      updateValues.push(new Date());

      // Execute update if there are fields to update
      if (updateFields.length > 2) { // More than just version and timestamp
        updateValues.push(votingBlocId);

        const updateQuery = `
          UPDATE "votingBlocs" 
          SET ${updateFields.join(', ')}
          WHERE id = $${paramIndex}
        `;

        await client.query(updateQuery, updateValues);

        // Log the sync
        await client.query(`
          INSERT INTO "votingBlocSyncLog" (
            "votingBlocId", "oldTemplateVersion", "newTemplateVersion", 
            "syncedFields", "changesSummary"
          ) VALUES ($1, $2, $3, $4, $5)
        `, [
          votingBlocId,
          oldTemplateVersion,
          newTemplateVersion,
          JSON.stringify(syncPreferences),
          changesSummary.join(', ')
        ]);

        await client.query('COMMIT');

        return {
          updated: true,
          oldVersion: oldTemplateVersion,
          newVersion: newTemplateVersion,
          changes: changesSummary
        };
      } else {
        // Just update version and timestamp
        await client.query(`
          UPDATE "votingBlocs" 
          SET "templateVersion" = $1, "lastSyncedAt" = $2
          WHERE id = $3
        `, [newTemplateVersion, new Date(), votingBlocId]);

        await client.query('COMMIT');

        return {
          updated: true,
          oldVersion: oldTemplateVersion,
          newVersion: newTemplateVersion,
          changes: ['Version updated (no content changes)']
        };
      }

    } catch (error) {
      await client.query('ROLLBACK');
      console.error('Error syncing voting bloc:', error);
      throw error;
    } finally {
      client.release();
    }
  }

  /**
   * Sync all outdated auto-generated voting blocs
   */
  static async syncAllOutdatedBlocs(syncFields = null) {
    try {
      const { outdatedBlocs, currentTemplateVersion } = await this.checkForOutdatedBlocs();

      if (outdatedBlocs.length === 0) {
        return { syncedCount: 0, message: 'All blocs are up to date' };
      }

      console.log(`ðŸ”„ Syncing ${outdatedBlocs.length} outdated voting blocs to template version ${currentTemplateVersion}`);

      const results = [];
      let successCount = 0;
      let errorCount = 0;

      for (const bloc of outdatedBlocs) {
        try {
          const result = await this.syncVotingBloc(bloc.id, syncFields);
          results.push({ votingBlocId: bloc.id, success: true, result });
          successCount++;
          console.log(`âœ… Synced voting bloc: ${bloc.name}`);
        } catch (error) {
          results.push({ votingBlocId: bloc.id, success: false, error: error.message });
          errorCount++;
          console.error(`âŒ Failed to sync voting bloc: ${bloc.name}`, error.message);
        }
      }

      return {
        syncedCount: successCount,
        errorCount,
        results,
        message: `Synced ${successCount} of ${outdatedBlocs.length} voting blocs`
      };

    } catch (error) {
      console.error('Error in bulk sync:', error);
      throw error;
    }
  }

  /**
   * Update sync preferences for a voting bloc
   */
  static async updateSyncPreferences(votingBlocId, preferences) {
    try {
      await query(`
        UPDATE "votingBlocs" 
        SET "syncPreferences" = $1
        WHERE id = $2 AND "isAutoGenerated" = true
      `, [JSON.stringify(preferences), votingBlocId]);

      return { success: true };
    } catch (error) {
      console.error('Error updating sync preferences:', error);
      throw error;
    }
  }

  /**
   * Get sync status for voting blocs
   */
  static async getSyncStatus() {
    try {
      const defaultSettings = await DefaultVotingBlocSettings.get();
      const currentTemplateVersion = defaultSettings.templateVersion || 1;

      const result = await query(`
        SELECT 
          COUNT(*) as total_auto_generated,
          COUNT(CASE WHEN "templateVersion" >= $1 THEN 1 END) as up_to_date,
          COUNT(CASE WHEN "templateVersion" < $1 OR "templateVersion" IS NULL THEN 1 END) as outdated,
          MAX("lastSyncedAt") as last_sync
        FROM "votingBlocs" 
        WHERE "isAutoGenerated" = true
      `, [currentTemplateVersion]);

      return {
        currentTemplateVersion,
        autoSyncEnabled: defaultSettings.autoSyncEnabled,
        statistics: result.rows[0]
      };
    } catch (error) {
      console.error('Error getting sync status:', error);
      throw error;
    }
  }
}

export { TemplateSyncService };
